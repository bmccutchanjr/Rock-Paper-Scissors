// A multi-user implementation of Rock/Paper/Scissors.  This script assumes no more than two players
// to a game, but does permit multiple games.

var database;               // the reference to the Firebase database

// I need a global variable so I can use it in $(document).unload().  I don't know how to pass a variable
// from .ready() to .unload().  I don't know that you can.  Now that database is global I don't need to
// pass it to functions any longer.

var gameID = "";            // The name of the Firebase node representing this game

// This is a 2-player game, but seems a small thing to allow more than one game at a time.  Just need
// to keep them separate.

var gameList = [];          // An array of active games retrieved from Firebase
var playerOne = "";
var playerTwo = "";
var playerCount = 0;
var iAmPlayerOne = false;
var messages = [];          // an array of messages generated by the script or sent by the players

// I was going to put messages[] on Firebase but it seems overly complicated, just pass the most recent
// message between players and concatenate the array in the script.  Much simpler, much cleaner.  It means
// the players won't see exactly the same messages...but the differences will be messages generated by
// the script specific to the players.  So that's okay. 

function pushMessage(message)
{   // concatenates messages[] for history and show the last two messages on the page

    messages.push(message);

    mLength = messages.length;

    var mDiv = $(".messages");
    mDiv.empty();

    for (var i=0; i<2; i++)
    {   var pTag = $("<p>");
        pTag
            .text(messages[mLength - (i + 1)]);

        mDiv
            .prepend(pTag);
    }
}

function setMessage(database, message)
{   // database.set() messages to Firebase

    database.ref(gameID + "/Message").set(
    {   Message: message
    })

}

function joinGame(database)
{   // Join a game already in progress

    // There should be a game in progress that is in need of a new player -- find it.

    var found = false;
    var count = 0;

    do
    {   // Peruse gameList[] for the first game in search of a player

        if (gameList[count].PlayerCount === 1)
        {   // gameList[count] needs a second player...this is our game

            // Update gameID.  This is our reference to Firbase for this game   
            gameID = gameList[count].GameID;

            // increment PlayerCount so no one else tries to connect to this game
            gameList[count].PlayerCount = 2;

            // update Firebase
            database.ref("Games").set(
            {   GameList: gameList
            });

            found = true;
        }
        else
        {   // increment count
            ++count;

            if (count > gameList.length)
            {   // this is an error, but it shouldn't happen.  Just in case, set found to break out
                // of the do-while and let the player know something is wrong.
                found = true;

                // Let the player know there is a problem
            }
        }

    } 
    while (!found);

console.log("joinGame()");
console.log(gameID);

    // I need a reference to the database to receive the /Names node before I can update names.  How
    // else can I know which player name to update?  initializeGame() does several .set() and that
    // seems to work, but that's initializeGame() and it setting default values.  Will setting a
    // message do the same for joinGame()?

    database.ref(gameID).set(
    {   Message:
        {   Message: "A new player is connecting"
        }
    });

// display dialog to input the player's name

// update the missing player name in the game object with the input name

// push() a challenge to the message array that is part of the game object.

// connect to the database node identified in gameID and use database.set() to update with the
// altered game object.

// return a reference to the game database
//     return database;
}

function makeGameID ()
{   // Generate a 8-character string to use as a gameID

    var char = "abcdefghijklmnopqrstuvwxyz0123456789";
    var charLen = char.length;
    var randomStr = "";

    for (var i=0; i<8; i++)
    {   var j = Math.floor(Math.random() * charLen);
        randomStr = randomStr + char.substring(j, j+1)
    }

    return randomStr;
}

// function initializeGame(db)
// I use database.set() in this, and other, functions.  To do that I need to make database a global
// variable (a practice that is frowned on) or pass a reference to these functions as a parameter.
// Passing a parameter is considered best practice.
//
// At first (as you can see in the commented code above) I used a different name in my functions.
// But simply using a different name here is enough to hose Firebase.  I have an event listener
// watching ".info/connections" to include the number of players connected, and that listener would
// fire twice, once when the page loads and the script connects to the database.  And that appeared to
// be working properly.  But then it would immediately fire again, this second time reporting there
// are 0 connections.  And sure enough, firebase.com no longer shows connections.
//
// And that's enough to hose the rest of the logic in my script.  With almost nothing coded almost
// nothing worked.  Among other things, the page would create a new game node every time it was loaded
// despite code to prevent that.
//
// So I commented all of the code not dealing specifically with the number of connections, and it
// worked properly once again.  Uncomment the function calls and the problems are back.  The functions
// appear to work properly, they're just executing when they shouldn't, so the problem has to be
// the function call.  Make database a global variable and change the function calls to not pass
// a parameter and everything still works.
//
// There is one more thing to look at.  Pass a reference to database in the function call once again,
// but use the same name in the functions.  It still works properly.
//
// So using a different name in my functions negates the database refence to Firebase?  WTF??
function initializeGame(database)
{   // Initialize a game

    // We're initializing a new game.  Just create a new gameID and .push() the reference to gameList[].

    gameID = makeGameID()

    gameList.push(
    {   GameID: gameID,
        PlayerCount: 1
    });
                
    database.ref("AllGames").set(
    {   GameList: gameList
    });

    // if the script is initializing the game, this is playerOne
    iAmPlayerOne = true;

    // And now create a node in Firebase for the new game
    //
    // The gameID node has three children -- each is a node of the database with its own
    // event listener
    //
    // /Names       the player's names
    // /Choices     the player choices, rock, paper or scissors
    // /Messages    the most recent message, whether generated by this script or sent by the
    //              players
    //
    // Since this happens before the player has had a chance to interact with the page, eveything get
    // initial values

    database.ref(gameID + "/Names").set(
    {   PlayerOne: "",
        PlayerTwo: ""
    })

    database.ref(gameID + "/Choices").set(
    {   PlayerOne: "",
        PlayerTwo: ""
    })

    database.ref(gameID + "/Message").set(
    {   Message: ""
    })
}

$(document)
.ready(function()
{   //
    //
    
    // Initialize Firebase

    var config =
    {   apiKey: "AIzaSyD1e2P0WVFVjRCewvFURl2lTpR26BwfG7c",
        authDomain: "rock-paper-scissors-2e60c.firebaseapp.com",
        databaseURL: "https://rock-paper-scissors-2e60c.firebaseio.com",
        projectId: "rock-paper-scissors-2e60c",
        storageBucket: "",
        messagingSenderId: "429649976880"
    };

    firebase.initializeApp(config);
    var database = firebase.database();

    var connectionsRef = database.ref("/connections");
    var connectedRef = database.ref(".info/connected");
  
    // The reference to the database node representing this game.  This is used throughout this
    // script
    var gameNode;
  
    database.ref("AllGames").on("value", function(snap)
    {   // The event handler for the ActiveGame node of the database.  This node has an array
        // describing the active games, including the game's ID, used to connect to a specific
        // game.  It is not the actual game.

console.log("activeRef.on()");
console.log("children: ", snap.numChildren());
        if (snap.val())
            gameList = snap.val().GameList;

console.log(gameList);

var counterDiv = $("#player-count");
            counterDiv.text(counterDiv.text() + " in " + gameList.length + " games");
    });

    database.ref(gameID + "/Names").on("value", function(snap)
    {   // The event listener for the  for the gameID/Name

console.log(gameID, "/Names.on()");
        if (snap.val())
        {   // I can't think of a simple method to determine whether this page represents player1
            // or player2 based on the values just received from Firebase.  If only player1 exists,
            // it could be because player1 just loaded the page and initialized the game.  If that's
            // this page represents player1.  But it might also mean that player1 has been connected
            // for some time and player2 has just loaded the page.  Firebase pushes this node to
            // player2 and it looks exactly as it did when player1 set it and received it.  You know
            // what's simple?  The page knows which player this is.  Its an intrinsic function of
            // loading the page.  So Firebase doesn't really help me here, and this event listener
            // doesn't really serve a purpose.
            //
            // But I'm going to do something with it anyway, just for the excersize.  Take the
            // values Firebase just pushed to this page and set global variable.  Also display the
            // names on the page.

            playerOne = snap.val().PlayerOne;
            playerTwo = snap.val().PlayerTwo;

            if (playerOne && playerTwo)
            {   // only do this if both player1 and player2 have connected
            
                var nameDiv = $("#your-name");
                var pTag = $("<p>");
                pTag.html("<b>" + playerOne + "</b> vs. <b>" + playerTwo + "</b>");
                nameDiv.append(pTag);
            }
        }
console.log("playerOne: ", playerOne);
console.log("playerTwo: ", playerTwo);
    });

    connectedRef.on("value", function(snap)
    {   // manage connections

        if (snap.val())
        {   // Add user to the connections list.
            var con = connectionsRef.push(true);

            // Remove user from the connection list when they disconnect.
// If I can, this is the place where I update the ActiveGame node to decrement the player count,
// or simply delete the node representing this game
            con.onDisconnect().remove();
        }
    });
  
    connectionsRef.on("value", function(snap)
    {   // When first loaded or when the connections list changes.

        var numPlayers = snap.numChildren();
        $("#player-count").text(numPlayers + " players");

console.log("connectionsRef.on()");
console.log("number: ", numPlayers);
console.log("gameID: ", gameID);

        // It's kinda neat to know how many people are connected and playing the game at any given
        // time.  But, I don't want to do anything else after the page is loaded and the player has
        // joined a game.

        if (gameID === "")
        {   // gameID is initialized to an empty string when the page loads.  So I know this is a
            // a player in search of a game, rather than someone already playing.

            if ((numPlayers % 2) != 0)
            {   // It takes two to play the game.  An odd number of players means there should not be a game
                // in need of a player, instead we have a player in need of a game.
                //
                // Initialize a game and wait for another player to connect the the database
console.log("initializeGame():");
                gameNode = initializeGame (database);
            }
            else
            {   // But an even number of players means that someone else should be connected and waiting
                // for an opponent.  Search the active games for a game that is short and join in
console.log("joinGame()");        
                gameNode = joinGame(database);
            }
        }
    })

    $("#name-button").on("click", function(event)
    {   // The event handler for #name-button

        event.preventDefault();

        console.log("#name-input");
        var name = $("#name-input").val().trim();

        if (name)
        {   // Only update the database if the user entered a name
        
            if (iAmPlayerOne)
                playerOne = name;
            else
                playerTwo = name;

            database.ref(gameID + "/Names").set(
            {   PlayerOne: playerOne,
                PlayerTwo: playerTwo
            })

            $("#your-name").text(name);

            $("#name-form").css("display", "none");

            pushMessage ("You will known as " + name);
            pushMessage ("Waiting for player two");
        }
    })
});

// $(window).unload(function()
// $(window).on("unload", function(event)
// function cleanUp()
// window.unload(function()
// window.beforeunload(function()
// $(window).beforeunload(function()
// $(window).on("beforeunload", function()
window.addEventListener("beforeunload", function(e)
{   // Things to do when the page is unloaded or otherwise refreshed
console.log("nothing works!");
// create a runtime fatal error...
alert.unload("unloading..."); 
return "JavaScript is shit!";
    if (playerCount === 1)
    {   // This is the last player connected to this Firebase node, this node is no longer needed
        // and may even cause problems when new players connect to this Firebase database.  So I
        // want to remove it.
    
        // First remove the associated element from AllGames.

        var gLength = gameList.length;

        for (var i=0; i<gLength; i++)
        {   if (gameID === gameList[i])
            {   gameID.splice(i);

                database.ref("AllGames").set(
                {   GameList: gameList
                })
            }
        }

        // Now remove the reference point for this game.  If I did this before .set() the altered
        // gameList to GameList there would be a small window of opportunity for a new user to connect
        // the Firebase and a obtain gameList that still has an element refering to this node, and then
        // try to connect to this reference point, which by that time could be deleted.  So modify the
        // array at GameList first, then .remove() this refence point
        
        database.ref(gameID).remove();
    }
    else
    {   // If playerCount is not equal to 1, someone is still connected to the reference point, and
        // may be willing to wait for another challenger.  So simply tell the other player that this
        // player has dropped and let the script for the still active player re-initialize the game

        setMessage ("Your opponent has dropped out");
    }

    // That seems a little too simple, but...
});
